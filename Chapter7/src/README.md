# 07 어댑터 패턴과 퍼사드 패턴

## 어댑터 패턴

![image](https://user-images.githubusercontent.com/44438366/202000905-d3f0e355-9d8d-4fbd-b416-cdedf90c447c.png)

특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환한다. 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도와준다.

![image](https://user-images.githubusercontent.com/44438366/202000963-831eb62e-4c05-4343-8a6a-c1989610f710.png)

composition을 사용하는 이유

- 어댑티의 모든 서브클래스에 어댑터를 쓸 수 있다는 장점이 있어서

이는 객체 어댑터고

클래스 어댑터도 있다.

![image](https://user-images.githubusercontent.com/44438366/202001024-8aa4bccf-b2ce-4a02-9def-dbe3f6e1e7ff.png)

클래스 어댑터는 다중 상속이 필요하다. 타깃과 어댑티 모두 서브클래스로 만들어서 사용하고, 객체 어댑터는 구성으로 어댑티에 요청을 전달한다는 점을 빼면 별로 다를 게 없다.

‘구성 vs 상속’임!!

- 어댑터의 유연성에 어떤 영향을 미칠까?
- 유연성 측면에선 ‘구성 > 상속’
- 어댑티 클래스와 그 서브클래스에대해서도 어댑터 역할을 할 수 있음.
- 어떤 행동을 추가하면 어댑터 코드는 어댑티 클래스와 더불어 모든 서브클래스에 그대로 적용됨
    - 어댑티의 서브클래스에서 새로운 행동을 추가하면, 서브클래스 레퍼런스만 가지고 있으면 문제가 되지 않음

### 데코레이터 vs 어댑터 패턴

- 데코레이터는 감싸고 있는 객체의 행동과 책임을 확장
- 어댑터는 실제로 인터페이스를 변환

## 퍼사드 패턴

객체를 감싸서 인터페이스를 단순화

퍼사드 패턴도 인터페이스를 변경하는 패턴임. 근데 이 패턴은 인터페이스를 단순하게 바꾸려고 인터페이스를 변경함.

하나 이상의 클래스 인터페이스를 깔끔하면서도 효과적인 퍼사드(facade: 겉모양, 외관)로 덮어줌.

![image](https://user-images.githubusercontent.com/44438366/202001083-dfa48e9a-b89d-4a49-9fbb-9a044132cba2.png)

![image](https://user-images.githubusercontent.com/44438366/202001112-b9fc04cc-61ad-4058-a08e-b7c491946604.png)

![image](https://user-images.githubusercontent.com/44438366/202001368-205c0aa8-7a34-4556-835d-2ae291c80326.png)

### 최소 지식 원칙(Principle of Least Knowledge)

객체 사이의 상호작용은 될 수 있으면 아주 가까운 ‘친구’사이에서만 허용하는 편이 좋다.

이 원칙을 잘 따르면 여러 클래스가 복잡하게 얽혀 있어서, 한 부분에 변경이 있을 때 다른 부분까지 줄줄이 고쳐야 하는 상황을 미리 방지할 수 있다.

![image](https://user-images.githubusercontent.com/44438366/202001318-67264b9c-61eb-4654-a9de-60f08cd97588.png)

객체의 한 구성 요소를 알고 지낼 필요가 없어짐. 친구를 줄이도록 객체가 대신 요청하도록 만들어야 함.

클라이언트가 퍼사드 하나만 친구로 두고, 호출하면, 최소 지식 원칙을 지키는 것!